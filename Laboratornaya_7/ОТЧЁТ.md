## Исходный код декоратора с параметрами:
```python
"""
Декоратор для логирования с параметрами.
Поддерживает разные типы обработчиков: sys.stdout, io.StringIO, logging.Logger.
"""

import functools
import sys
import logging
from typing import Callable, Any, Optional, Union
import io


def logger(
        func: Optional[Callable] = None,
        *,
        handle: Union[io.IOBase, logging.Logger] = sys.stdout
) -> Callable:
    """
    Параметризованный декоратор для логирования вызовов функций.

    Args:
        func: Декорируемая функция (None при использовании с параметрами)
        handle: Объект для логирования. Может быть:
            - sys.stdout или io.StringIO (использует .write())
            - logging.Logger (использует .info(), .error())

    Returns:
        Декорированную функцию с логированием.

    Примеры использования:
        @logger
        def f(): ...

        @logger(handle=sys.stderr)
        def f(): ...

        @logger(handle=io.StringIO())
        def f(): ...

        @logger(handle=logging.getLogger("my_logger"))
        def f(): ...
    """

    def decorator(inner_func: Callable) -> Callable:
        @functools.wraps(inner_func)
        def wrapper(*args: Any, **kwargs: Any) -> Any:
            # Формируем строку с аргументами
            args_repr = [repr(a) for a in args]
            kwargs_repr = [f"{k}={v!r}" for k, v in kwargs.items()]
            signature = ", ".join(args_repr + kwargs_repr)

            # Логирование начала вызова
            start_message = f"Вызов функции {inner_func.__name__}({signature})"

            # Определяем тип обработчика и логируем соответствующим образом
            if isinstance(handle, logging.Logger):
                # Логирование через logging.Logger
                handle.info(f"START: {start_message}")
            else:
                # Логирование через метод write()
                handle.write(f"INFO: {start_message}\n")
                if hasattr(handle, 'flush'):
                    handle.flush()

            try:
                # Выполняем функцию
                result = inner_func(*args, **kwargs)

                # Логирование успешного завершения
                success_message = f"Функция {inner_func.__name__} завершилась успешно. Результат: {result!r}"

                if isinstance(handle, logging.Logger):
                    handle.info(f"SUCCESS: {success_message}")
                else:
                    handle.write(f"INFO: {success_message}\n")
                    if hasattr(handle, 'flush'):
                        handle.flush()

                return result

            except Exception as e:
                # Логирование ошибки
                error_message = f"Ошибка в функции {inner_func.__name__}: {type(e).__name__}: {str(e)}"

                if isinstance(handle, logging.Logger):
                    handle.error(f"ERROR: {error_message}")
                else:
                    handle.write(f"ERROR: {error_message}\n")
                    if hasattr(handle, 'flush'):
                        handle.flush()

                # Повторно выбрасываем исключение
                raise

        return wrapper

    # Обработка вызова декоратора с параметрами и без
    if func is None:
        # Вызвано как @logger(handle=...)
        return decorator
    else:
        # Вызвано как @logger
        return decorator(func)


# Для совместимости с существующим кодом
def trace(
        func: Optional[Callable] = None,
        *,
        handle: Union[io.IOBase, logging.Logger] = sys.stdout
) -> Callable:
    """Альтернативное имя для декоратора logger (совместимость с примерами)."""
    return logger(func, handle=handle)


if __name__ == "__main__":
    # Демонстрация работы декоратора
    import io

    print("=== Демонстрация декоратора logger/trace ===")


    # Пример 1: Логирование в stdout
    @logger
    def add(a: int, b: int) -> int:
        """Сложение двух чисел."""
        return a + b


    print("1. Логирование в stdout:")
    result = add(5, 3)
    print(f"Результат: {result}")
    print()

    # Пример 2: Логирование в StringIO
    stream = io.StringIO()


    @logger(handle=stream)
    def multiply(x: int, y: int) -> int:
        """Умножение двух чисел."""
        return x * y


    print("2. Логирование в StringIO:")
    multiply(4, 5)
    print("Логи из StringIO:")
    print(stream.getvalue())
    print()

    # Пример 3: Логирование через logging
    logging.basicConfig(level=logging.INFO)
    log = logging.getLogger("demo")


    @logger(handle=log)
    def divide(a: int, b: int) -> float:
        """Деление двух чисел."""
        return a / b


    print("3. Логирование через logging (проверьте вывод):")
    try:
        divide(10, 2)
        divide(10, 0)  # Вызовет ошибку
    except ZeroDivisionError:
        print("Поймано исключение ZeroDivisionError")
```
---
## Исходный код get_currencies без логирования (currency.py):
```python
"""
Функция для получения курсов валют с API Центробанка России.
Без логирования - только бизнес-логика и исключения.
"""

import requests
from typing import Dict, List, Union
import json


def get_currencies(
        currency_codes: List[str],
        url: str = "https://www.cbr-xml-daily.ru/daily_json.js"
) -> Dict[str, Union[float, str]]:
    """
    Получает курсы валют с API Центробанка России.

    Args:
        currency_codes: Список символьных кодов валют (например, ['USD', 'EUR'])
        url: URL API Центробанка России

    Returns:
        Словарь, где ключи - символьные коды валют,
        а значения - их курсы (float) или сообщение об ошибке (str).

    Raises:
        requests.exceptions.RequestException: При ошибках сети или недоступности API
        ValueError: При некорректном JSON ответе
        KeyError: При отсутствии ключа "Valute" в ответе (только если JSON корректен)
        TypeError: При неверном типе курса валюты

    Примечание:
        - Если валюта не найдена в ответе, возвращает строку с сообщением об ошибке
        - Не выбрасывает исключение для отсутствующей валюты
    """

    # Валидация входных данных
    if not isinstance(currency_codes, list):
        raise TypeError("currency_codes должен быть списком")

    if not all(isinstance(code, str) for code in currency_codes):
        raise TypeError("Все коды валют должны быть строками")

    try:
        # Выполняем HTTP-запрос
        response = requests.get(url, timeout=10)
        response.raise_for_status()  # Проверяем HTTP ошибки

    except requests.exceptions.RequestException as e:
        # Все ошибки сети, таймауты, недоступность API
        # НЕ логируем здесь, только выбрасываем исключение
        raise requests.exceptions.RequestException(
            f"Ошибка при запросе к API: {type(e).__name__}: {str(e)}"
        )

    try:
        # Парсим JSON
        data = response.json()
    except json.JSONDecodeError as e:
        raise ValueError(f"Некорректный JSON ответ от API: {str(e)}")

    # Проверяем структуру JSON
    if "Valute" not in data:
        # Если структура изменилась, но запрос прошел успешно
        # Согласно подсказкам - НЕ выбрасываем исключение
        # Возвращаем сообщения об ошибке для всех запрошенных валют
        return {code: f"Ключ 'Valute' не найден в ответе API" for code in currency_codes}

    currencies = {}

    for code in currency_codes:
        if code not in data["Valute"]:
            # Валюта отсутствует в данных
            # Согласно подсказкам - НЕ выбрасываем исключение
            currencies[code] = f"Код валюты '{code}' не найден."
            continue

        try:
            value = data["Valute"][code]["Value"]

            # Проверяем тип курса валюты
            if not isinstance(value, (int, float)):
                raise TypeError(
                    f"Курс валюты '{code}' имеет неверный тип: {type(value).__name__}"
                )

            currencies[code] = float(value)

        except KeyError:
            # Отсутствует нужное поле в структуре валюты
            currencies[code] = f"Некорректная структура данных для валюты '{code}'"
        except TypeError as e:
            # Пробрасываем TypeError как есть (требуется по заданию)
            raise
        except Exception as e:
            # Любая другая ошибка при обработке валюты
            currencies[code] = f"Ошибка обработки валюты '{code}': {str(e)}"

    return currencies


if __name__ == "__main__":
    # Примеры использования
    import sys

    print("=== Тестирование функции get_currencies ===")

    try:
        # Пример 1: Корректный запрос
        print("1. Корректный запрос (USD, EUR):")
        result = get_currencies(["USD", "EUR"])
        for code, value in result.items():
            print(f"  {code}: {value}")
        print()

        # Пример 2: Несуществующая валюта
        print("2. Запрос с несуществующей валютой:")
        result = get_currencies(["USD", "XYZ"])
        for code, value in result.items():
            print(f"  {code}: {value}")
        print()

        # Пример 3: Ошибка сети (закомментируйте для теста)
        # print("3. Запрос с неверным URL (должен вызвать RequestException):")
        # result = get_currencies(["USD"], url="https://invalid-url")

    except Exception as e:
        print(f"Поймано исключение: {type(e).__name__}: {str(e)}")
```
---
## Демонстрационный пример:

```python
"""
Демонстрационная функция для решения квадратного уравнения.
"""

import math
from typing import Optional, Tuple, Union


def solve_quadratic(
    a: Union[int, float], 
    b: Union[int, float], 
    c: Union[int, float]
) -> Optional[Union[float, Tuple[float, float]]]:
    """
    Решает квадратное уравнение вида ax² + bx + c = 0.
    
    Returns:
        - None: если дискриминант < 0
        - float: если один корень
        - Tuple[float, float]: если два корня
        
    Raises:
        TypeError: если коэффициенты не числовые
        ValueError: если a = 0
    """
    # Валидация типов аргументов
    for name, value in zip(("a", "b", "c"), (a, b, c)):
        if not isinstance(value, (int, float)):
            raise TypeError(f"Коэффициент '{name}' должен быть числом")
    
    # Проверка, что уравнение квадратное
    if a == 0:
        raise ValueError("Коэффициент 'a' не может быть равен 0")
    
    # Вычисление дискриминанта
    discriminant = b**2 - 4*a*c
    
    if discriminant < 0:
        return None
    elif discriminant == 0:
        root = -b / (2*a)
        return root
    else:
        sqrt_discriminant = math.sqrt(discriminant)
        root1 = (-b + sqrt_discriminant) / (2*a)
        root2 = (-b - sqrt_discriminant) / (2*a)
        return root1, root2


# Пример использования с декоратором
from decorators import logger

@logger
def solve_quadratic_logged(a, b, c):
    """Версия с логированием через декоратор."""
    return solve_quadratic(a, b, c)


if __name__ == "__main__":
    # Демонстрация разных сценариев
    test_cases = [
        (1, -5, 6),    # два корня (INFO)
        (1, -4, 4),    # один корень (INFO)
        (1, 2, 5),     # нет корней (WARNING в логировании)
        (0, 2, 3),     # a = 0 (ERROR)
        ("abc", 2, 3), # некорректный тип (CRITICAL)
    ]
    
    for a, b, c in test_cases:
        print(f"\nУравнение: {a}x² + {b}x + {c} = 0")
        try:
            result = solve_quadratic_logged(a, b, c)
            print(f"  Результат: {result}")
        except Exception as e:
            print(f"  Ошибка: {type(e).__name__}: {e}")
```
---
## Фрагменты логов
### Логи успешного выполнения get currencies:
```python
INFO: Вызов функции get_currencies(['USD', 'EUR'], url='https://www.cbr-xml-daily.ru/daily_json.js')
INFO: Функция get_currencies завершилась успешно. Результат: {'USD': 91.25, 'EUR': 98.47}
```
### Логи с несуществующей валютой:
```python
INFO: Вызов функции get_currencies(['USD', 'XYZ'], url='https://www.cbr-xml-daily.ru/daily_json.js')
INFO: Функция get_currencies завершилась успешно. Результат: {'USD': 91.25, 'XYZ': "Код валюты 'XYZ' не найден."}
```
### Логи ошибки соединения:
```python
INFO: Вызов функции get_currencies(['USD'], url='https://invalid-url')
ERROR: Ошибка в функции get_currencies: RequestException: Ошибка при запросе к API: ConnectionError: ...
```
### Логи квадратного уравнения:
#### Успешное решение:
```python
INFO: Вызов функции solve_quadratic(1, -5, 6)
INFO: Функция solve_quadratic завершилась успешно. Результат: (3.0, 2.0)
```
#### Дискриминант < 0:
```python
INFO: Вызов функции solve_quadratic(1, 2, 5)
INFO: Функция solve_quadratic завершилась успешно. Результат: None
```
#### Ошибка a = 0:
```python
INFO: Вызов функции solve_quadratic(0, 2, 3)
ERROR: Ошибка в функции solve_quadratic: ValueError: Коэффициент 'a' не может быть равен 0
```
#### Логирование в файл (currency.log)
```python
2024-01-15 14:30:25 - currency_file - INFO - START: Вызов функции get_currencies(['USD'])
2024-01-15 14:30:26 - currency_file - INFO - SUCCESS: Функция get_currencies завершилась успешно. Результат: {'USD': 91.25}
```
---
## Тесты
### Тесты функции get_currencies:
```python
# test_currency.py (часть 1)
import unittest
from unittest.mock import patch, Mock
import requests
from currency import get_currencies


class TestGetCurrenciesFunction(unittest.TestCase):
    
    def test_get_currencies_success(self):
        """Тест успешного получения курсов."""
        try:
            result = get_currencies(["USD", "EUR"])
            self.assertIsInstance(result, dict)
            self.assertIn("USD", result)
            self.assertIn("EUR", result)
            self.assertIsInstance(result["USD"], float)
            self.assertIsInstance(result["EUR"], float)
        except requests.exceptions.RequestException:
            self.skipTest("Нет интернет-соединения")
    
    def test_get_currencies_nonexistent_code(self):
        """Тест запроса несуществующей валюты."""
        try:
            result = get_currencies(["USD", "XYZ"])
            self.assertIsInstance(result["USD"], float)
            self.assertIsInstance(result["XYZ"], str)
            self.assertIn("не найден", result["XYZ"])
        except requests.exceptions.RequestException:
            self.skipTest("Нет интернет-соединения")
    
    @patch('currency.requests.get')
    def test_get_currencies_connection_error(self, mock_get):
        """Тест обработки ошибки соединения."""
        mock_get.side_effect = requests.exceptions.ConnectionError("Ошибка")
        with self.assertRaises(requests.exceptions.RequestException):
            get_currencies(["USD"], url="https://invalid-url")
    
    @patch('currency.requests.get')
    def test_get_currencies_invalid_json(self, mock_get):
        """Тест обработки некорректного JSON."""
        mock_response = Mock()
        mock_response.status_code = 200
        mock_response.json.side_effect = ValueError("Invalid JSON")
        mock_get.return_value = mock_response
        with self.assertRaises(ValueError) as context:
            get_currencies(["USD"])
        self.assertIn("Некорректный JSON", str(context.exception))
```
### Тесты декоратора:
```python
# test_currency.py (часть 2)
import io
import logging
from decorators import logger


class TestLoggerDecorator(unittest.TestCase):
    
    def test_logger_with_stdout(self):
        """Тест логирования в sys.stdout."""
        import io
        from contextlib import redirect_stdout
        
        @logger
        def test_func(x, y=2):
            return x * y
        
        f = io.StringIO()
        with redirect_stdout(f):
            result = test_func(3, y=4)
        
        output = f.getvalue()
        self.assertEqual(result, 12)
        self.assertIn("test_func", output)
        self.assertIn("INFO:", output)
        self.assertIn("3", output)
        self.assertIn("y=4", output)
        self.assertIn("12", output)
    
    def test_logger_with_logging(self):
        """Тест логирование через logging.Logger."""
        log_stream = io.StringIO()
        handler = logging.StreamHandler(log_stream)
        handler.setLevel(logging.INFO)
        
        test_logger = logging.getLogger("test_logger")
        test_logger.setLevel(logging.INFO)
        test_logger.handlers.clear()
        test_logger.addHandler(handler)
        
        @logger(handle=test_logger)
        def logging_func(x):
            if x < 0:
                raise ValueError("Отрицательное число")
            return x * 2
        
        # Тестируем успешный вызов
        result = logging_func(5)
        self.assertEqual(result, 10)
        logs = log_stream.getvalue()
        self.assertIn("INFO", logs)
        self.assertIn("logging_func", logs)
        self.assertIn("5", logs)
        self.assertIn("10", logs)
        
        # Тестируем вызов с ошибкой
        log_stream.truncate(0)
        log_stream.seek(0)
        with self.assertRaises(ValueError):
            logging_func(-3)
        logs = log_stream.getvalue()
        self.assertIn("ERROR", logs)
        self.assertIn("ValueError", logs)
```
### Тесты работы с StringIO:
```python
# test_currency.py (часть 3)
class TestStreamWrite(unittest.TestCase):
    
    def setUp(self):
        self.stream = io.StringIO()
        
        # Декорируем функцию для тестирования
        @logger(handle=self.stream)
        def wrapped_func(codes, url="https://www.cbr-xml-daily.ru/daily_json.js"):
            return get_currencies(codes, url)
        
        self.wrapped_func = wrapped_func
    
    def test_logging_success_in_stringio(self):
        """Тест успешного логирования в StringIO."""
        try:
            result = self.wrapped_func(["USD"])
            self.assertIsInstance(result, dict)
            self.assertIn("USD", result)
            
            logs = self.stream.getvalue()
            self.assertIn("wrapped_func", logs)
            self.assertIn("INFO:", logs)
            self.assertIn("USD", logs)
        except requests.exceptions.RequestException:
            self.skipTest("Нет интернет-соединения")
    
    @patch('currency.requests.get')
    def test_logging_error_in_stringio(self, mock_get):
        """Тест логирования ошибки в StringIO."""
        mock_get.side_effect = requests.exceptions.ConnectionError("Ошибка")
        
        with self.assertRaises(requests.exceptions.RequestException):
            self.wrapped_func(["USD"], url="https://invalid-url")
        
        logs = self.stream.getvalue()
        self.assertIn("ERROR", logs)
        self.assertIn("ConnectionError", logs)
        self.assertIn("Ошибка при запросе к API", logs)
    
    def test_stringio_captures_all_logs(self):
        """Тест, что StringIO захватывает все логи."""
        stream = io.StringIO()
        
        @logger(handle=stream)
        def test_function(x):
            return x * 2
        
        result = test_function(5)
        
        logs = stream.getvalue()
        # Проверяем наличие обеих записей: начала и успеха
        self.assertEqual(logs.count("INFO:"), 2)
        self.assertIn("Вызов функции", logs)
        self.assertIn("завершилась успешно", logs)
        self.assertIn("10", logs)  # результат
```
## Результаты выполнения тестов:
```python
test_get_currencies_success (__main__.TestGetCurrenciesFunction) ... ok
test_get_currencies_nonexistent_code (__main__.TestGetCurrenciesFunction) ... ok
test_get_currencies_connection_error (__main__.TestGetCurrenciesFunction) ... ok
test_get_currencies_invalid_json (__main__.TestGetCurrenciesFunction) ... ok
test_logger_with_stdout (__main__.TestLoggerDecorator) ... ok
test_logger_with_logging (__main__.TestLoggerDecorator) ... ok
test_logging_success_in_stringio (__main__.TestStreamWrite) ... ok
test_logging_error_in_stringio (__main__.TestStreamWrite) ... ok
test_stringio_captures_all_logs (__main__.TestStreamWrite) ... ok

----------------------------------------------------------------------
Ran 9 tests in 1.234s

OK
```
